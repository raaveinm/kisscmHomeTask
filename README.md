# kisscmHomeTask
MIREA



---
# First task
---
  Разработать эмулятор для языка оболочки ОС
  Эмулятор должен запускаться из реальной командной строки, а файл с
виртуальной файловой системой не нужно распаковывать у пользователя.
Эмулятор принимает образ виртуальной файловой системы в виде файла формата
tar. Эмулятор должен работать в режиме CLI.
---
# Реализация:

1.  **Запуск эмулятора:** 
    Программа запускается из командной строки и принимает следующие аргументы:
    *   Имя компьютера (для отображения в приглашении командной строки)
    *   Путь к tar-архиву с виртуальной файловой системой
    *   Путь к json-файлу для записи логов
    *   Путь к скрипту для начальной инициализации

2.  **Доступные команды:**
    *   `ls`: Выводит список файлов и директорий в текущей директории.
    *   `cd`: Изменяет текущую директорию.
    *   `exit`: Завершает работу эмулятора.
    *   `rev`: Переворачивает строку.
    *   `uptime`: Показывает время работы эмулятора.

3.  **Работа с файловой системой:**
    *   Виртуальная файловая система загружается из tar-архива.
    *   Программа поддерживает навигацию по директориям и вывод списка файлов.

4.  **Логирование:**
    *   Все выполненные команды и их результаты записываются в json-файл.

**Структура проекта:**

*   `CmdEmulator.java`: Главный класс программы.
*   `CommandExecutor.java`: Класс для выполнения команд.
*   `FileSystem.java`: Класс для работы с файловой системой.
*   `LsCommand.java`, `CdCommand.java`, `ExitCommand.java`, `RevCommand.java`, `UptimeCommand.java`: Классы, реализующие команды.

**Зависимости:**

*   Программа использует библиотеки для работы с tar-архивами и json-файлами.

---
# Second task
---
Разработать инструмент командной строки для визуализации графа
зависимостей, включая транзитивные зависимости. Зависимости определяются для файла-пакета ОС Manjaro (pacman). Для описания
графа зависимостей используется представление Graphviz.
---
**Реализация:**

```bash
python script.py <graphviz_path> <package_name> <depth>
```

*   `<graphviz_path>`: Путь к исполняемому файлу Graphviz `dot`.
*   `<package_name>`: Имя пакета Manjaro для анализа зависимостей.
*   `<depth>`:  Максимальная глубина транзитивных зависимостей для включения в граф.

**Пример:**

```bash
python script.py /usr/bin/dot firefox 3 > firefoxDependencies.png
```

Эта команда сгенерирует граф зависимостей для пакета `firefox` с глубиной 3 и использует `/usr/bin/dot` для визуализации и выводит файл firefoxDependencies.png.

**Функциональность:**

1.  **Получение зависимостей:**
    *   Использует `pacman -Qi` для получения информации о пакете.
    *   Извлекает список зависимостей из выходных данных `pacman`.
    *   Рекурсивно получает транзитивные зависимости до заданной глубины.

2.  **Генерация DOT:**
    *   Создает код Graphviz DOT для представления графа зависимостей.
    *   Отмечает основной пакет как узел с другим стилем (форма коробки).
    *   Связывает зависимости с помощью стрелок.

3.  **Визуализация:**
    *   Использует Graphviz `dot` для преобразования кода DOT в изображение PNG.
    *   Выводит изображение PNG в стандартный вывод.

**Зависимости:**

*   Python 3
*   pacman
*   Graphviz
  
---
# Third task
---
  Разработать инструмент командной строки, преобразующий текст из
входного формата в выходной. Синтаксические ошибки выявляются с выдачей
сообщений.
  Входной текст принимается из стандартного ввода. Выходной текст на языке json попадает в файл, путь к
которому задан ключом командной строки.
---
# Реализация:

```
java Main -o <output_file>
```

*   `<output_file>`: Путь к файлу, в который будет записан выходной JSON.

**Пример:**

```
java Main -o output.json
```

**Входной формат:**

Входной формат представляет собой набор инструкций, которые могут быть:

*   Объявления констант: `const NAME = value;`
*   Выражения: `value;`

Значения могут быть:

*   Числа: `123`
*   Строки: `"hello"` или `'world'`
*   Имена констант: `NAME`
*   Массивы: `![(value, value, ...)]`
*   Словари: `@{ "key": value, "key": value, ... }`
*   Выражения в скобках: `(value + value)`

**Выходной формат:**

Выходной формат представляет собой JSON-представление входных данных.

**Синтаксический анализ:**

Инструмент выполняет синтаксический анализ входного текста, чтобы убедиться, что он соответствует ожидаемому формату. В случае обнаружения синтаксических ошибок, инструмент выводит сообщения об ошибках.

**Обработка ошибок:**

*   Инструмент обрабатывает ошибки ввода-вывода, такие как ошибки чтения из стандартного ввода или записи в файл.
*   Инструмент обрабатывает синтаксические ошибки во входном тексте.

**Зависимости:**

*   Программа использует библиотеки для работы с JSON.


**Структура проекта:**

*   `Main.java`: Главный класс программы, обрабатывает аргументы командной строки, читает входные данные и записывает выходные данные.
*   `Parser.java`: Класс, отвечающий за синтаксический анализ входного текста и построение представления данных.
*   `Token.java`: Класс, представляющий лексему во входном тексте.
*   `TokenType.java`: Перечисление, определяющее типы лексем.
*   `JsonConverter.java`: Класс, преобразующий данные в JSON-формат.

---
# Fourth task
---
  Разработать ассемблер и интерпретатор. Для ассемблера необходимо разработать читаемое представление команд. Ассемблер принимает на вход файл с текстом исходной программы, путь к которой задается из командной строки. Результатом работы ассемблера является бинарный файл в виде последовательности байт, путь к которому задается из командной строки. Дополнительный ключ командной строки задает путь к файлу-логу, в котором хранятся ассемблированные инструкции в духе списков “ключ=значение”, как в приведенных далее тестах.
  Интерпретатор принимает на вход бинарный файл, выполняет команды и сохраняет в файле-результате значения из диапазона памяти УВМ. Диапазон также указывается из командной строки. Форматом для файла-лога и файла-результата является csv.
---
# Реализация:

**Ассемблер:**

*   **Вход:** Текстовый файл с ассемблерным кодом, где каждая строка содержит одну инструкцию.
*   **Выход:** Бинарный файл с последовательностью байтов, представляющих инструкции UVM.
*   **Лог-файл:** Файл, содержащий список ассемблированных инструкций в формате "ключ=значение".
*   **Формат инструкции:** `<команда> <операнд>`
*   **Поддерживаемые команды:**
    *   `LOAD`: Загружает значение в аккумулятор.
    *   `READ`: Читает значение из памяти в аккумулятор.
    *   `WRITE`: Записывает значение из аккумулятора в память.
    *   `SGN`: Вычисляет знак числа в памяти и сохраняет его в аккумулятор и память.

**Интерпретатор:**

*   **Вход:** Бинарный файл, сгенерированный ассемблером.
*   **Выход:** CSV-файл с значениями из указанного диапазона памяти после выполнения программы.
*   **Память:** UVM имеет 256 байт памяти.
*   **Аккумулятор:**  Регистр для хранения промежуточных значений.

**Использование:**

**Ассемблер:**

```bash
java UVMAssembler <input_file> <output_file> <log_file>
```

*   `<input_file>`: Путь к файлу с ассемблерным кодом.
*   `<output_file>`: Путь к бинарному файлу для записи результата.
*   `<log_file>`: Путь к файлу для записи лога.

**Интерпретатор:**

```bash
java UVMInterpreter <input_file> <output_file> <start_address> <end_address>
```

*   `<input_file>`: Путь к бинарному файлу с программой UVM.
*   `<output_file>`: Путь к CSV-файлу для записи результата.
*   `<start_address>`: Начальный адрес диапазона памяти для вывода.
*   `<end_address>`: Конечный адрес диапазона памяти для вывода.

**Пример:**

**program.asm:**

```assembly
LOAD 0
READ 0
SGN 0
WRITE 0
```

**Команда ассемблирования:**

```bash
java UVMAssembler program.asm program.bin program.log
```

**Команда интерпретации:**

```bash
java UVMInterpreter program.bin result.csv 0 7
```

**Структура проекта:**

*   `UVMAssembler.java`:  Содержит код ассемблера.
*   `UVMInterpreter.java`: Содержит код интерпретатора.
